lua_package_path "/usr/local/openresty/lualib/?.lua;/usr/local/openresty/lualib/prometheus/?.lua;/etc/nginx/lua/?.lua;;";
lua_shared_dict prometheus_metrics 10M;
lua_shared_dict geoip_cache 10M;
lua_shared_dict rate_limit 10M;

# Enable debug logging specifically for Lua
error_log /var/log/nginx/lua_debug.log debug;

# Initialize Prometheus metrics with enhanced error handling
init_worker_by_lua_block {
    -- Wrap everything in pcall for better error handling
    local function safe_init()
        ngx.log(ngx.INFO, "Starting Prometheus initialization...")
        
        -- Test basic Lua functionality first
        ngx.log(ngx.INFO, "Testing basic Lua functionality...")
        
        -- Try to require modules with better error handling
        local prometheus_ok, prometheus = pcall(require, "prometheus")
        if not prometheus_ok then
            ngx.log(ngx.ERR, "Failed to load prometheus module: ", prometheus)
            return false
        end
        ngx.log(ngx.INFO, "prometheus module loaded successfully")
        
        local geoip_ok, geoip = pcall(require, "geoip")
        if not geoip_ok then
            ngx.log(ngx.ERR, "Failed to load geoip module: ", geoip)
            return false
        end
        ngx.log(ngx.INFO, "geoip module loaded successfully")
        
        local metrics_ok, metrics = pcall(require, "metrics")
        if not metrics_ok then
            ngx.log(ngx.ERR, "Failed to load metrics module: ", metrics)
            return false
        end
        ngx.log(ngx.INFO, "metrics module loaded successfully")
        
        -- Make modules global
        _G.prometheus = prometheus
        _G.geoip = geoip
        _G.metrics = metrics
        
        -- Initialize prometheus instance with error handling
        ngx.log(ngx.INFO, "Initializing prometheus instance...")
        local prom_ok, prom = pcall(prometheus.init, "prometheus_metrics")
        if not prom_ok then
            ngx.log(ngx.ERR, "Failed to initialize prometheus: ", prom)
            return false
        end
        _G.prom = prom
        ngx.log(ngx.INFO, "Prometheus instance created successfully")
        
        -- Test shared dictionary access
        local dict = ngx.shared.prometheus_metrics
        if not dict then
            ngx.log(ngx.ERR, "prometheus_metrics shared dict not found!")
            return false
        end
        ngx.log(ngx.INFO, "Shared dictionary accessible, capacity: ", dict:capacity())
        
        -- HTTP Request Metrics with error handling
        ngx.log(ngx.INFO, "Creating counter metrics...")
        local counter_ok, metric_requests = pcall(prom.counter, prom,
            "nginx_http_requests_total", 
            "Total HTTP requests", 
            {"method", "status", "endpoint", "country", "country_code", "city", "source"}
        )
        if not counter_ok then
            ngx.log(ngx.ERR, "Failed to create requests counter: ", metric_requests)
            return false
        end
        _G.metric_requests = metric_requests
        ngx.log(ngx.INFO, "Requests counter created successfully")
        
        ngx.log(ngx.INFO, "Creating histogram metrics...")
        local hist_ok, metric_request_duration = pcall(prom.histogram, prom,
            "nginx_http_request_duration_seconds", 
            "HTTP request duration in seconds",
            {"method", "status", "endpoint", "country", "timing_bucket"},
            {0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0, 7.5, 10.0}
        )
        if not hist_ok then
            ngx.log(ngx.ERR, "Failed to create duration histogram: ", metric_request_duration)
            return false
        end
        _G.metric_request_duration = metric_request_duration
        ngx.log(ngx.INFO, "Duration histogram created successfully")
        
        local size_ok, metric_request_size = pcall(prom.histogram, prom,
            "nginx_http_request_size_bytes", 
            "HTTP request size in bytes",
            {"method", "endpoint", "size_bucket"},
            {1, 50, 100, 1000, 10000, 100000, 1000000, 10000000}
        )
        if not size_ok then
            ngx.log(ngx.ERR, "Failed to create request size histogram: ", metric_request_size)
            return false
        end
        _G.metric_request_size = metric_request_size
        
        local resp_size_ok, metric_response_size = pcall(prom.histogram, prom,
            "nginx_http_response_size_bytes", 
            "HTTP response size in bytes",
            {"method", "status", "endpoint", "size_bucket"},
            {1, 50, 100, 1000, 10000, 100000, 1000000, 10000000}
        )
        if not resp_size_ok then
            ngx.log(ngx.ERR, "Failed to create response size histogram: ", metric_response_size)
            return false
        end
        _G.metric_response_size = metric_response_size
        
        -- Geographic Metrics
        ngx.log(ngx.INFO, "Creating geographic metrics...")
        local geo_country_ok, metric_requests_by_country = pcall(prom.counter, prom,
            "nginx_http_requests_by_country_total",
            "Total HTTP requests by country",
            {"country", "country_code", "continent"}
        )
        if not geo_country_ok then
            ngx.log(ngx.ERR, "Failed to create country counter: ", metric_requests_by_country)
            return false
        end
        _G.metric_requests_by_country = metric_requests_by_country
        
        local geo_city_ok, metric_requests_by_city = pcall(prom.counter, prom,
            "nginx_http_requests_by_city_total",
            "Total HTTP requests by city",
            {"city", "region", "country", "country_code"}
        )
        if not geo_city_ok then
            ngx.log(ngx.ERR, "Failed to create city counter: ", metric_requests_by_city)
            return false
        end
        _G.metric_requests_by_city = metric_requests_by_city
        
        local datacenter_ok, metric_requests_by_datacenter = pcall(prom.counter, prom,
            "nginx_http_requests_by_cloudflare_datacenter_total",
            "Total HTTP requests by Cloudflare datacenter",
            {"datacenter", "country"}
        )
        if not datacenter_ok then
            ngx.log(ngx.ERR, "Failed to create datacenter counter: ", metric_requests_by_datacenter)
            return false
        end
        _G.metric_requests_by_datacenter = metric_requests_by_datacenter
        
        -- Performance Metrics by Geography  
        ngx.log(ngx.INFO, "Creating performance metrics...")
        local p95_ok, metric_p95_latency_by_country = pcall(prom.gauge, prom,
            "nginx_http_p95_latency_by_country_seconds",
            "95th percentile latency by country",
            {"country", "country_code"}
        )
        if not p95_ok then
            ngx.log(ngx.ERR, "Failed to create p95 gauge: ", metric_p95_latency_by_country)
            return false
        end
        _G.metric_p95_latency_by_country = metric_p95_latency_by_country
        
        local p99_ok, metric_p99_latency_by_country = pcall(prom.gauge, prom,
            "nginx_http_p99_latency_by_country_seconds", 
            "99th percentile latency by country",
            {"country", "country_code"}
        )
        if not p99_ok then
            ngx.log(ngx.ERR, "Failed to create p99 gauge: ", metric_p99_latency_by_country)
            return false
        end
        _G.metric_p99_latency_by_country = metric_p99_latency_by_country
        
        -- Additional Metrics (simplified for debugging)
        ngx.log(ngx.INFO, "Creating additional metrics...")
        _G.metric_requests_by_browser = prom:counter(
            "nginx_http_requests_by_browser_total",
            "Total HTTP requests by browser",
            {"browser", "os", "device"}
        )
        
        _G.metric_requests_by_status_category = prom:counter(
            "nginx_http_requests_by_status_category_total",
            "Total HTTP requests by status category",
            {"category", "country", "endpoint"}
        )
        
        _G.metric_requests_by_asn = prom:counter(
            "nginx_http_requests_by_asn_total",
            "Total HTTP requests by ASN",
            {"asn", "country"}
        )
        
        _G.metric_rate_limited_requests = prom:counter(
            "nginx_http_rate_limited_requests_total",
            "Total rate limited requests",
            {"country", "endpoint", "limit_type"}
        )
        
        _G.metric_suspicious_requests = prom:counter(
            "nginx_http_suspicious_requests_total",
            "Total suspicious/bot requests",
            {"country", "user_agent_type", "reason"}
        )
        
        _G.metric_cf_cache_status = prom:counter(
            "nginx_http_cloudflare_cache_status_total",
            "Cloudflare cache status",
            {"status", "country", "endpoint"}
        )
        
        -- Initialize GeoIP
        ngx.log(ngx.INFO, "Initializing GeoIP...")
        local geoip_init_ok, geoip_err = pcall(geoip.init)
        if not geoip_init_ok then
            ngx.log(ngx.ERR, "Failed to initialize GeoIP: ", geoip_err)
            return false
        end
        
        ngx.log(ngx.INFO, "Prometheus metrics initialized successfully with Cloudflare GeoIP support")
        return true
    end
    
    -- Run initialization
    local init_ok, init_err = pcall(safe_init)
    if not init_ok then
        ngx.log(ngx.ERR, "Fatal error during initialization: ", init_err)
        -- Set a flag to indicate initialization failed
        ngx.shared.prometheus_metrics:set("_init_failed", "true")
    else
        ngx.shared.prometheus_metrics:set("_init_success", "true")
        ngx.log(ngx.INFO, "All initialization completed successfully!")
    end
}

# Log phase to collect metrics with enhanced error handling
log_by_lua_block {
    -- Check if initialization was successful
    if ngx.shared.prometheus_metrics:get("_init_failed") then
        ngx.log(ngx.ERR, "Skipping metrics collection due to initialization failure")
        return
    end
    
    -- Wrap metrics collection in pcall
    local function safe_log()
        -- Get basic request data with safety checks
        local request_time = tonumber(ngx.var.request_time) or 0
        local request_length = tonumber(ngx.var.request_length) or 0
        local bytes_sent = tonumber(ngx.var.bytes_sent) or 0
        local status = ngx.var.status or "0"
        local method = ngx.var.request_method or "UNKNOWN"
        local uri = ngx.var.uri or "/"
        local user_agent = ngx.var.http_user_agent or ""
        
        ngx.log(ngx.DEBUG, "Processing request: ", method, " ", uri, " status: ", status)
        
        -- Check if required globals exist
        if not _G.metrics then
            ngx.log(ngx.ERR, "metrics module not available in log phase")
            return
        end
        
        -- Normalize endpoint for better grouping
        local endpoint_ok, endpoint = pcall(_G.metrics.categorize_request, uri, method)
        if not endpoint_ok then
            ngx.log(ngx.ERR, "Error categorizing request: ", endpoint)
            endpoint = "/other"
        end
        
        -- Get timing and size buckets for better aggregation
        local timing_bucket_ok, timing_bucket = pcall(_G.metrics.timing_bucket, request_time)
        if not timing_bucket_ok then
            ngx.log(ngx.ERR, "Error getting timing bucket: ", timing_bucket)
            timing_bucket = "unknown"
        end
        
        local req_size_bucket_ok, req_size_bucket = pcall(_G.metrics.size_bucket, request_length)
        if not req_size_bucket_ok then
            ngx.log(ngx.ERR, "Error getting request size bucket: ", req_size_bucket)
            req_size_bucket = "unknown"
        end
        
        local resp_size_bucket_ok, resp_size_bucket = pcall(_G.metrics.size_bucket, bytes_sent)
        if not resp_size_bucket_ok then
            ngx.log(ngx.ERR, "Error getting response size bucket: ", resp_size_bucket)
            resp_size_bucket = "unknown"
        end
        
        local status_category_ok, status_category = pcall(_G.metrics.status_category, status)
        if not status_category_ok then
            ngx.log(ngx.ERR, "Error getting status category: ", status_category)
            status_category = "unknown"
        end
        
        -- Get GeoIP data from Cloudflare headers with error handling
        if not _G.geoip then
            ngx.log(ngx.ERR, "geoip module not available in log phase")
            return
        end
        
        local geo_ok, geo_data = pcall(_G.geoip.lookup, ngx.var.remote_addr)
        if not geo_ok then
            ngx.log(ngx.ERR, "Error in GeoIP lookup: ", geo_data)
            geo_data = {
                country = "unknown",
                country_code = "unknown", 
                city = "unknown",
                region = "unknown",
                continent = "unknown",
                cf_datacenter = "unknown",
                asn = "unknown",
                source = "error"
            }
        end
        
        local country = geo_data.country or "unknown"
        local country_code = geo_data.country_code or "unknown"
        local city = geo_data.city or "unknown"
        local region = geo_data.region or "unknown"
        local continent = geo_data.continent or "unknown"
        local datacenter = geo_data.cf_datacenter or "unknown"
        local asn = geo_data.asn or "unknown"
        local source = geo_data.source or "unknown"
        
        ngx.log(ngx.DEBUG, "GeoIP data: country=", country, " city=", city, " datacenter=", datacenter)
        
        -- Parse user agent with error handling
        local ua_ok, ua_data = pcall(_G.metrics.parse_user_agent, user_agent)
        if not ua_ok then
            ngx.log(ngx.ERR, "Error parsing user agent: ", ua_data)
            ua_data = {browser = "unknown", os = "unknown", device = "unknown"}
        end
        
        -- Get Cloudflare specific data with error handling
        local cf_ok, cf_info = pcall(_G.geoip.get_cloudflare_info)
        if not cf_ok then
            ngx.log(ngx.ERR, "Error getting Cloudflare info: ", cf_info)
        end
        local cf_cache_status = ngx.var.http_cf_cache_status or "unknown"
        
        -- Record basic metrics with error handling
        if _G.metric_requests then
            local req_ok, req_err = pcall(_G.metric_requests.inc, _G.metric_requests, 1, {method, status, endpoint, country, country_code, city, source})
            if not req_ok then
                ngx.log(ngx.ERR, "Error recording request metric: ", req_err)
            end
        end
        
        if _G.metric_request_duration then
            local dur_ok, dur_err = pcall(_G.metric_request_duration.observe, _G.metric_request_duration, request_time, {method, status, endpoint, country, timing_bucket})
            if not dur_ok then
                ngx.log(ngx.ERR, "Error recording duration metric: ", dur_err)
            end
        end
        
        if _G.metric_request_size then
            local req_size_ok, req_size_err = pcall(_G.metric_request_size.observe, _G.metric_request_size, request_length, {method, endpoint, req_size_bucket})
            if not req_size_ok then
                ngx.log(ngx.ERR, "Error recording request size metric: ", req_size_err)
            end
        end
        
        if _G.metric_response_size then
            local resp_size_ok, resp_size_err = pcall(_G.metric_response_size.observe, _G.metric_response_size, bytes_sent, {method, status, endpoint, resp_size_bucket})
            if not resp_size_ok then
                ngx.log(ngx.ERR, "Error recording response size metric: ", resp_size_err)
            end
        end
        
        -- Geographic metrics
        if _G.metric_requests_by_country then
            local country_ok, country_err = pcall(_G.metric_requests_by_country.inc, _G.metric_requests_by_country, 1, {country, country_code, continent})
            if not country_ok then
                ngx.log(ngx.ERR, "Error recording country metric: ", country_err)
            end
        end
        
        if _G.metric_requests_by_city then
            local city_ok, city_err = pcall(_G.metric_requests_by_city.inc, _G.metric_requests_by_city, 1, {city, region, country, country_code})
            if not city_ok then
                ngx.log(ngx.ERR, "Error recording city metric: ", city_err)
            end
        end
        
        -- Cloudflare datacenter metrics
        if datacenter ~= "unknown" and _G.metric_requests_by_datacenter then
            local dc_ok, dc_err = pcall(_G.metric_requests_by_datacenter.inc, _G.metric_requests_by_datacenter, 1, {datacenter, country})
            if not dc_ok then
                ngx.log(ngx.ERR, "Error recording datacenter metric: ", dc_err)
            end
        end
        
        -- User agent metrics
        if _G.metric_requests_by_browser then
            local browser_ok, browser_err = pcall(_G.metric_requests_by_browser.inc, _G.metric_requests_by_browser, 1, {ua_data.browser, ua_data.os, ua_data.device})
            if not browser_ok then
                ngx.log(ngx.ERR, "Error recording browser metric: ", browser_err)
            end
        end
        
        -- Status category metrics
        if _G.metric_requests_by_status_category then
            local status_ok, status_err = pcall(_G.metric_requests_by_status_category.inc, _G.metric_requests_by_status_category, 1, {status_category, country, endpoint})
            if not status_ok then
                ngx.log(ngx.ERR, "Error recording status category metric: ", status_err)
            end
        end
        
        -- ASN metrics
        if asn ~= "unknown" and _G.metric_requests_by_asn then
            local asn_ok, asn_err = pcall(_G.metric_requests_by_asn.inc, _G.metric_requests_by_asn, 1, {asn, country})
            if not asn_ok then
                ngx.log(ngx.ERR, "Error recording ASN metric: ", asn_err)
            end
        end
        
        -- Cloudflare cache status
        if cf_cache_status ~= "unknown" and _G.metric_cf_cache_status then
            local cache_ok, cache_err = pcall(_G.metric_cf_cache_status.inc, _G.metric_cf_cache_status, 1, {cf_cache_status, country, endpoint})
            if not cache_ok then
                ngx.log(ngx.ERR, "Error recording cache status metric: ", cache_err)
            end
        end
        
        -- Simple bot detection
        if _G.metric_suspicious_requests and (user_agent == "" or 
           string.match(user_agent:lower(), "bot") or 
           string.match(user_agent:lower(), "crawler") or
           string.match(user_agent:lower(), "spider")) then
            local bot_ok, bot_err = pcall(_G.metric_suspicious_requests.inc, _G.metric_suspicious_requests, 1, {country, "bot", "user_agent"})
            if not bot_ok then
                ngx.log(ngx.ERR, "Error recording suspicious request metric: ", bot_err)
            end
        end
        
        -- Rate limiting check (example) with error handling
        if _G.metrics and _G.metric_rate_limited_requests then
            local client_ip = geo_data.real_ip or ngx.var.remote_addr
            local rate_key = country_code .. ":" .. client_ip
            local rate_ok, rate_allowed = pcall(_G.metrics.check_rate_limit, rate_key, 100, 60, "rate_limit")
            if rate_ok and not rate_allowed and _G.metric_rate_limited_requests then
                local limit_ok, limit_err = pcall(_G.metric_rate_limited_requests.inc, _G.metric_rate_limited_requests, 1, {country, endpoint, "per_ip"})
                if not limit_ok then
                    ngx.log(ngx.ERR, "Error recording rate limit metric: ", limit_err)
                end
            end
        end
        
        ngx.log(ngx.DEBUG, "Metrics collection completed successfully")
    end
    
    -- Execute metrics collection
    local log_ok, log_err = pcall(safe_log)
    if not log_ok then
        ngx.log(ngx.ERR, "Error in metrics collection: ", log_err)
    end
}

# Prometheus metrics endpoint with enhanced error handling
server {
    listen 9145;
    server_name _;
    
    location /metrics {
        access_log off;
        content_by_lua_block {
            -- Check initialization status
            if ngx.shared.prometheus_metrics:get("_init_failed") then
                ngx.status = 500
                ngx.header.content_type = "text/plain"
                ngx.say("Error: Prometheus initialization failed")
                return
            end
            
            if not _G.prometheus or not _G.prom then
                ngx.status = 500
                ngx.header.content_type = "text/plain"
                ngx.say("Error: Prometheus not initialized")
                return
            end
            
            local collect_ok, collect_err = pcall(_G.prom.collect, _G.prom)
            if not collect_ok then
                ngx.status = 500
                ngx.header.content_type = "text/plain"
                ngx.say("Error collecting metrics: " .. tostring(collect_err))
                return
            end
        }
    }
    
    location /health {
        access_log off;
        content_by_lua_block {
            ngx.header.content_type = "text/plain"
            if ngx.shared.prometheus_metrics:get("_init_success") then
                ngx.say("healthy - prometheus initialized")
            elseif ngx.shared.prometheus_metrics:get("_init_failed") then
                ngx.status = 500
                ngx.say("unhealthy - prometheus initialization failed")
            else
                ngx.status = 503
                ngx.say("initializing")
            end
        }
    }
    
    location /debug {
        access_log off;
        content_by_lua_block {
            ngx.header.content_type = "text/plain"
            
            ngx.say("=== DEBUG INFO ===")
            ngx.say("OpenResty version: ", ngx.config.nginx_version)
            ngx.say("LuaJIT version: ", jit and jit.version or "Not available")
            ngx.say("")
            
            local dict = ngx.shared.prometheus_metrics
            if dict then
                ngx.say("=== SHARED DICTIONARY ===")
                ngx.say("Capacity: ", dict:capacity())
                ngx.say("Free space: ", dict:free_space())
                ngx.say("Key count: ", #dict:get_keys(0))
                ngx.say("Init success: ", dict:get("_init_success") or "false")
                ngx.say("Init failed: ", dict:get("_init_failed") or "false")
                ngx.say("")
            end
            
            ngx.say("=== LUA PACKAGE PATH ===")
            ngx.say("package.path: ", package.path or "Not set")
            ngx.say("")
            
            ngx.say("=== GLOBAL VARIABLES ===")
            ngx.say("_G.prometheus available: ", _G.prometheus ~= nil)
            ngx.say("_G.prom available: ", _G.prom ~= nil)
            ngx.say("_G.geoip available: ", _G.geoip ~= nil)
            ngx.say("_G.metrics available: ", _G.metrics ~= nil)
            ngx.say("")
            
            if dict then
                ngx.say("=== SAMPLE KEYS ===")
                local keys = dict:get_keys(10)  -- Get first 10 keys
                for i, key in ipairs(keys) do
                    local value = dict:get(key)
                    ngx.say(key, " = ", value or "nil")
                end
            end
        }
    }
}

# Status endpoint for connection metrics
server {
    listen 8080;
    server_name _;
    
    location /nginx_status {
        stub_status on;
        access_log off;
        allow 172.16.0.0/12;  # Docker network
        allow 127.0.0.1;      # localhost
        deny all;
    }
    
    location /lua_status {
        access_log off;
        allow 172.16.0.0/12;  # Docker network
        allow 127.0.0.1;      # localhost
        deny all;
        content_by_lua_block {
            ngx.header.content_type = "text/plain"
            local dict = ngx.shared.prometheus_metrics
            if dict then
                ngx.say("Prometheus metrics dictionary size: ", #dict:get_keys(0))
                ngx.say("Free space: ", dict:free_space())
                ngx.say("Capacity: ", dict:capacity())
            else
                ngx.say("Dictionary not found!")
            end
        }
    }
}
