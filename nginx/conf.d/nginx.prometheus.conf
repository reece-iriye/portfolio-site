lua_package_path "/usr/local/openresty/lualib/?.lua;/etc/nginx/lua/?.lua;;";
lua_shared_dict prometheus_metrics 10M;
lua_shared_dict geoip_cache 10M;
lua_shared_dict rate_limit 10M;

# Initialize Prometheus metrics
init_worker_by_lua_block {
    prometheus = require "prometheus"
    geoip = require "geoip"
    metrics = require "metrics"
    
    -- Initialize prometheus instance
    prom = prometheus.init("prometheus_metrics")
    
    -- HTTP Request Metrics
    metric_requests = prom:counter(
        "nginx_http_requests_total", 
        "Total HTTP requests", 
        {"method", "status", "endpoint", "country", "country_code", "city", "source"}
    )
    
    metric_request_duration = prom:histogram(
        "nginx_http_request_duration_seconds", 
        "HTTP request duration in seconds",
        {"method", "status", "endpoint", "country", "timing_bucket"},
        {0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0, 7.5, 10.0}
    )
    
    metric_request_size = prom:histogram(
        "nginx_http_request_size_bytes", 
        "HTTP request size in bytes",
        {"method", "endpoint", "size_bucket"},
        {1, 50, 100, 1000, 10000, 100000, 1000000, 10000000}
    )
    
    metric_response_size = prom:histogram(
        "nginx_http_response_size_bytes", 
        "HTTP response size in bytes",
        {"method", "status", "endpoint", "size_bucket"},
        {1, 50, 100, 1000, 10000, 100000, 1000000, 10000000}
    )
    
    -- Geographic Metrics
    metric_requests_by_country = prom:counter(
        "nginx_http_requests_by_country_total",
        "Total HTTP requests by country",
        {"country", "country_code", "continent"}
    )
    
    metric_requests_by_city = prom:counter(
        "nginx_http_requests_by_city_total",
        "Total HTTP requests by city",
        {"city", "region", "country", "country_code"}
    )
    
    metric_requests_by_datacenter = prom:counter(
        "nginx_http_requests_by_cloudflare_datacenter_total",
        "Total HTTP requests by Cloudflare datacenter",
        {"datacenter", "country"}
    )
    
    -- Performance Metrics by Geography  
    metric_p95_latency_by_country = prom:gauge(
        "nginx_http_p95_latency_by_country_seconds",
        "95th percentile latency by country",
        {"country", "country_code"}
    )
    
    metric_p99_latency_by_country = prom:gauge(
        "nginx_http_p99_latency_by_country_seconds", 
        "99th percentile latency by country",
        {"country", "country_code"}
    )
    
    -- User Agent / Device Metrics
    metric_requests_by_browser = prom:counter(
        "nginx_http_requests_by_browser_total",
        "Total HTTP requests by browser",
        {"browser", "os", "device"}
    )
    
    -- Status Code Metrics
    metric_requests_by_status_category = prom:counter(
        "nginx_http_requests_by_status_category_total",
        "Total HTTP requests by status category",
        {"category", "country", "endpoint"}
    )
    
    -- ASN/ISP Metrics
    metric_requests_by_asn = prom:counter(
        "nginx_http_requests_by_asn_total",
        "Total HTTP requests by ASN",
        {"asn", "country"}
    )
    
    -- Rate Limiting Metrics
    metric_rate_limited_requests = prom:counter(
        "nginx_http_rate_limited_requests_total",
        "Total rate limited requests",
        {"country", "endpoint", "limit_type"}
    )
    
    -- Bot/Security Metrics  
    metric_suspicious_requests = prom:counter(
        "nginx_http_suspicious_requests_total",
        "Total suspicious/bot requests",
        {"country", "user_agent_type", "reason"}
    )
    
    -- Cloudflare Specific Metrics
    metric_cf_cache_status = prom:counter(
        "nginx_http_cloudflare_cache_status_total",
        "Cloudflare cache status",
        {"status", "country", "endpoint"}
    )
    
    -- Initialize GeoIP
    geoip.init()
    
    ngx.log(ngx.INFO, "Prometheus metrics initialized with Cloudflare GeoIP support")
}

# Log phase to collect metrics
log_by_lua_block {
    local request_time = tonumber(ngx.var.request_time) or 0
    local request_length = tonumber(ngx.var.request_length) or 0
    local bytes_sent = tonumber(ngx.var.bytes_sent) or 0
    local status = ngx.var.status
    local method = ngx.var.request_method
    local uri = ngx.var.uri
    local user_agent = ngx.var.http_user_agent or ""
    
    -- Normalize endpoint for better grouping
    local endpoint = metrics.categorize_request(uri, method)
    
    -- Get timing and size buckets for better aggregation
    local timing_bucket = metrics.timing_bucket(request_time)
    local req_size_bucket = metrics.size_bucket(request_length)
    local resp_size_bucket = metrics.size_bucket(bytes_sent)
    local status_category = metrics.status_category(status)
    
    -- Get GeoIP data from Cloudflare headers
    local geo_data = geoip.lookup(ngx.var.remote_addr)
    local country = geo_data.country or "unknown"
    local country_code = geo_data.country_code or "unknown"
    local city = geo_data.city or "unknown"
    local region = geo_data.region or "unknown"
    local continent = geo_data.continent or "unknown"
    local datacenter = geo_data.cf_datacenter or "unknown"
    local asn = geo_data.asn or "unknown"
    local source = geo_data.source or "unknown"
    
    -- Parse user agent
    local ua_data = metrics.parse_user_agent(user_agent)
    
    -- Get Cloudflare specific data
    local cf_info = geoip.get_cloudflare_info()
    local cf_cache_status = ngx.var.http_cf_cache_status or "unknown"
    
    -- Record basic metrics
    metric_requests:inc(1, {method, status, endpoint, country, country_code, city, source})
    metric_request_duration:observe(request_time, {method, status, endpoint, country, timing_bucket})
    metric_request_size:observe(request_length, {method, endpoint, req_size_bucket})
    metric_response_size:observe(bytes_sent, {method, status, endpoint, resp_size_bucket})
    
    -- Geographic metrics
    metric_requests_by_country:inc(1, {country, country_code, continent})
    metric_requests_by_city:inc(1, {city, region, country, country_code})
    
    -- Cloudflare datacenter metrics
    if datacenter ~= "unknown" then
        metric_requests_by_datacenter:inc(1, {datacenter, country})
    end
    
    -- User agent metrics
    metric_requests_by_browser:inc(1, {ua_data.browser, ua_data.os, ua_data.device})
    
    -- Status category metrics
    metric_requests_by_status_category:inc(1, {status_category, country, endpoint})
    
    -- ASN metrics
    if asn ~= "unknown" then
        metric_requests_by_asn:inc(1, {asn, country})
    end
    
    -- Cloudflare cache status
    if cf_cache_status ~= "unknown" then
        metric_cf_cache_status:inc(1, {cf_cache_status, country, endpoint})
    end
    
    -- Simple bot detection
    if user_agent == "" or 
       string.match(user_agent:lower(), "bot") or 
       string.match(user_agent:lower(), "crawler") or
       string.match(user_agent:lower(), "spider") then
        metric_suspicious_requests:inc(1, {country, "bot", "user_agent"})
    end
    
    -- Rate limiting check (example)
    local client_ip = geo_data.real_ip or ngx.var.remote_addr
    local rate_key = country_code .. ":" .. client_ip
    if not metrics.check_rate_limit(rate_key, 100, 60, "rate_limit") then
        metric_rate_limited_requests:inc(1, {country, endpoint, "per_ip"})
    end
}

# Prometheus metrics endpoint
server {
    listen 9145;
    server_name _;
    
    location /metrics {
        access_log off;
        content_by_lua_block {
            local ok, err = prometheus:collect()
            if not ok then
                ngx.status = 500
                ngx.say("Error collecting metrics: ", err)
                return
            end
        }
    }
    
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}

# Status endpoint for connection metrics
server {
    listen 8080;
    server_name _;
    
    location /nginx_status {
        stub_status on;
        access_log off;
        allow 172.16.0.0/12;  # Docker network
        deny all;
    }
    
    location /lua_status {
        access_log off;
        content_by_lua_block {
            local dict = ngx.shared.prometheus_metrics
            ngx.say("Prometheus metrics dictionary size: ", dict:get_keys(0))
            ngx.say("Free space: ", dict:free_space())
            ngx.say("Capacity: ", dict:capacity())
        }
    }
}
